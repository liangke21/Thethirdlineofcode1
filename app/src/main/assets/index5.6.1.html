<!doctype html>

<title>CodeMirror: C-like mode</title>
<meta charset="utf-8"/>
<link rel=stylesheet href="rely/docs.css">                                       
<link rel="stylesheet" href="rely/codemirror.css">

<link rel="stylesheet" href="rely/idea.css">                                             <!-- 主题背景 -->

<script src="rely/codemirror.js"></script>
<script src="rely//matchbrackets.js"></script>
<link rel="stylesheet" href="rely/show-hint.css">
<script src="rely/show-hint.js"></script>
<script src="rely/clike.js"></script>
<style>.CodeMirror {border: 2px inset #dee;}</style>

<h2>大有用途的扩展函数6.1</h2>

<div><textarea id="kotlin-code">
package com.example.kotlinketang
import org.junit.Test
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        println(StringUtil.lenttersCount("你好123456abc"))//11
        var a="123456789年后".lettersCount()
        println(a)//11
    }
     object StringUtil{
         fun lenttersCount(str: String):Int{
             var count=0
             for (char in str){
                 count++
             }
             return count
         }//方法
     }//object StringUtil

    fun String.lettersCount():Int{
        var count=0
        for (char in this){
            count++
        }
/*这个扩展函数定义成了Srting,那么函数中就有了Srting上下文,所以这个函数就不再需要接收
* 一个字符串参数*/
        return count
    }//扩展函数
/*    扩展函数也是可以定义在任何一个类中,并非一定要创建一个新文件,
    最好定义成顶层方法
    *Srting是一个final类任何一个函数都不能继承它也就是api只有固定的几个
    在Kotlin中我们可以向Srting扩展*/
}
</textarea></div>

<h2>有趣的运算符6.2</h2>

<div><textarea id="kotlin-code1">
    //plus为减号 minus为减号
class Money(val value: Int) {

        operator fun plus(money:Money):Money{
           println(value)//输出5
            println(money.value)//输出1
            val sum=value+money.value

            return Money(sum)
        }

}

fun main(){
Money(5).plus(Money(1))
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Money(val value: Int) {
        operator fun plus(money:Money):Money{
            val sum=value+money.value
            return Money(sum)
        }
}
fun main(){
    val a=Money(5)
    val b=Money(10)
    val c=a+b
    println(c.value)//15
    //在Kotlin中给我们替换成了a.plus(b)这样是不是懂了
    //倍加数为传入方法
}
/////////////////////////////////////////////
    class Money(val value: Int) {
        operator fun plus(money:Money):Money{
            val sum=value+money.value
            return Money(sum)
        }
    operator fun plus(int: Int):Money{
        val sum=value+int
        return Money(sum)
    }
}
fun main(){
    val a=Money(5)
    val b=Money(10)
    val c=a+b
    val d=c+20//被加数是int就去找int的方法了
    println(d.value)//35
}
<!--
    语法糖表达式和实际调用函数对照表:

语法糖表达式	实际调用函数
a + b	a.plus(b)
a - b	a.minus(b)
a * b	a.times(b)
a / b	a.div(b)
a % b	a.rem(b)
a++	    a.inc()
a–	    a.dec()
+a	    a.unaryPlus()
-a	    a.unaryMinus()
a == b	a.equals(b)
a > b	a.compareTo(b)
a < b	a.compareTo(b)
a >= b	a.compareTo(b)
a <= b	a.compareTo(b)
a…b	    a.rangeTo(b)
a[b]	a.get(b)
a[b]=c	a.set(b,c)
a in b	b.contains(a)
!a	a.not()
注意 a in b 的语法糖表达式为b.contains(a) ,a, b是反过来的,这其实也很好理解,因为a in b是判断a在没有在b中
fun main() {
    if ("he" in "hello") {
        println("yes")
    } else {
        println("no")
    }
}
-->



</textarea></div>
<h2>扩展函数的随机数语法糖</h2>

<div><textarea id="kotlin-code3">
package com.example.kotlinketang

import org.junit.Test
operator fun String.times(n: Int): String {
    val builder = StringBuffer()
    repeat(n) {
        builder.append(this)
    }
    return builder.toString()
}
val str="abc"*3
class Money() {

}
fun main(){
    println( str)//abcabcabc

}
/*语法糖写法*/
//operator fun String.times(i: Int)=repeat(i){}
//fun getran(STR:String)=str*(1..20).random()


</textarea></div>


<script>

var kotlinEditor = CodeMirror.fromTextArea(document.getElementById("kotlin-code3"), {
          lineNumbers: true,
          matchBrackets: true,
		  theme: "idea",       <!-- 主题背景 -->
          mode: "text/x-kotlin"
      });


var kotlinEditor = CodeMirror.fromTextArea(document.getElementById("kotlin-code1"), {
lineNumbers: true,
matchBrackets: true,
theme: "idea",       <!-- 主题背景 -->
mode: "text/x-kotlin"
});


      var kotlinEditor = CodeMirror.fromTextArea(document.getElementById("kotlin-code"), {
          lineNumbers: true,
          matchBrackets: true,
		  theme: "idea",       <!-- 主题背景 -->
          mode: "text/x-kotlin"
      });


      var mac = CodeMirror.keyMap.default == CodeMirror.keyMap.macDefault;
      CodeMirror.keyMap.default[(mac ? "Cmd" : "Ctrl") + "-Space"] = "autocomplete";
    </script>

